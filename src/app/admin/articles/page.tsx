'use client';

import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { Article, ArticleStatus, ArticleCountByCategory, PaginatedArticles } from '@/app/model/article';
import Link from 'next/link';
import CategoryModal from '@/components/admin/CategoryModal';
import { Table, Input, Select, Button, Space, message as antMessage, Tag } from 'antd';
import { PlusOutlined, ApartmentOutlined, HolderOutlined } from '@ant-design/icons';
import type { ColumnsType } from 'antd/es/table';
import { articlesService } from '@/app/business/articles';
import { DndProvider, useDrag, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';


// ÊãñÊãΩË°åÁªÑ‰ª∂
interface DragableRowProps {
  index: number;
  moveRow: (dragIndex: number, hoverIndex: number) => void;
  className?: string;
  style?: React.CSSProperties;
  children?: React.ReactNode;
  'data-row-key'?: string;
}

const DragableRow: React.FC<DragableRowProps> = ({ index, moveRow, className, style, children, ...restProps }) => {
  const ref = useRef<HTMLTableRowElement>(null);

  const [{ handlerId }, drop] = useDrop<
    { index: number },
    void,
    { handlerId: unknown }
  >({
    accept: 'row',
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId(),
      };
    },
    hover(item, monitor) {
      if (!ref.current) {
        return;
      }
      const dragIndex = item.index;
      const hoverIndex = index;

      if (dragIndex === hoverIndex) {
        return;
      }

      const hoverBoundingRect = ref.current?.getBoundingClientRect();
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const clientOffset = monitor.getClientOffset();
      const hoverClientY = clientOffset!.y - hoverBoundingRect.top;

      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
        return;
      }

      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
        return;
      }

      moveRow(dragIndex, hoverIndex);
      item.index = hoverIndex;
    },
  });

  const [{ isDragging }, drag] = useDrag<
    { index: number },
    void,
    { isDragging: boolean }
  >({
    type: 'row',
    item: { index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });

  const opacity = isDragging ? 0.5 : 1;

  drag(drop(ref));

  return (
    <tr
      ref={ref}
      className={className}
      style={{ cursor: 'move', opacity, ...style }}
      data-handler-id={handlerId}
      {...restProps}
    >
      {children}
    </tr>
  );
};

// ÁºìÂ≠òÁÆ°ÁêÜÁ±ª
class ArticleCache {
  private cache = new Map<string, { data: PaginatedArticles; timestamp: number }>();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5ÂàÜÈíüÁºìÂ≠òÊó∂Èó¥

  // ÁîüÊàêÁºìÂ≠òÈîÆ
  private getCacheKey(params: any): string {
    return JSON.stringify(params);
  }

  // Ëé∑ÂèñÁºìÂ≠òÊï∞ÊçÆ
  get(params: any): PaginatedArticles | null {
    const key = this.getCacheKey(params);
    const cached = this.cache.get(key);

    if (!cached) return null;

    // Ê£ÄÊü•ÊòØÂê¶ËøáÊúü
    if (Date.now() - cached.timestamp > this.CACHE_TTL) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  // ËÆæÁΩÆÁºìÂ≠òÊï∞ÊçÆ
  set(params: any, data: PaginatedArticles): void {
    const key = this.getCacheKey(params);
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  // Ê∏ÖÁ©∫ÁºìÂ≠ò
  clear(): void {
    this.cache.clear();
  }

  // Ê†πÊçÆÊ®°ÂºèÊ∏ÖÈô§ÁºìÂ≠ò
  clearByPattern(pattern: RegExp): void {
    const keys = Array.from(this.cache.keys());
    for (const key of keys) {
      if (pattern.test(key)) {
        this.cache.delete(key);
      }
    }
  }
}

const articleCache = new ArticleCache();

const { Search } = Input;

// Ë°®Ê†ºÂàóÈÖçÁΩÆ
const getColumns = (
  categories: ArticleCountByCategory[],
  handleDelete: (id: string) => void,
  canSort: boolean
): ColumnsType<Article> => {
  const baseColumns: ColumnsType<Article> = [
    {
      title: 'Ê†áÈ¢ò',
      dataIndex: 'title',
      key: 'title',
      render: (text: string, record: Article) => (
        <Space>
          {canSort && <HolderOutlined style={{ cursor: 'move', color: '#999' }} />}
          <Link href={`/admin/articles/edit/${record._id}`} className="text-blue-500 hover:text-blue-600">
            {text}
          </Link>
        </Space>
      ),
    },
    {
      title: 'ÂàÜÁ±ª',
      dataIndex: 'categoryId',
      key: 'category',
      render: (categoryId: string) => categories.find(c => c.categoryId === categoryId)?.categoryName || '-',
    },
    {
      title: 'Áä∂ÊÄÅ',
      dataIndex: 'status',
      key: 'status',
      render: (status: ArticleStatus) => (
        <Tag color={status === ArticleStatus.PUBLISHED ? 'success' : 'warning'}>
          {status === ArticleStatus.PUBLISHED ? 'Â∑≤ÂèëÂ∏É' : 'ËçâÁ®ø'}
        </Tag>
      ),
    },
    {
      title: 'ÊéíÂ∫è',
      dataIndex: 'order',
      key: 'order',
      width: 100,
      render: (order: number) => order || 0,
    },
    {
      title: 'Êõ¥Êñ∞Êó∂Èó¥',
      dataIndex: 'updatedAt',
      key: 'updatedAt',
      render: (date: string) => date ? new Date(date).toLocaleDateString() : '-',
    },
    {
      title: 'Êìç‰Ωú',
      key: 'action',
      render: (_: any, record: Article) => (
        <Space size="middle">
          <Link href={`/admin/articles/edit/${record._id}`} className="text-blue-500 hover:text-blue-600">
            ÁºñËæë
          </Link>
          <Button type="link" danger onClick={() => handleDelete(record._id!.toString())}>
            Âà†Èô§
          </Button>
        </Space>
      ),
    },
  ];

  return baseColumns;
};

const ArticlesPage = () => {
  const [articles, setArticles] = useState<Article[]>([]);
  const [originalArticles, setOriginalArticles] = useState<Article[]>([]);
  const [categories, setCategories] = useState<ArticleCountByCategory[]>([]);
  const [loading, setLoading] = useState(false);
  const [searchText, setSearchText] = useState('');
  const [statusFilter, setStatusFilter] = useState<ArticleStatus | ''>('');
  const [categoryFilter, setCategoryFilter] = useState<string>('');
  const [showCategoryModal, setShowCategoryModal] = useState(false);
  const [sortBy, setSortBy] = useState<'latest' | 'order'>('order');

  // ÂàÜÈ°µÁä∂ÊÄÅ
  const [pagination, setPagination] = useState({
    current: 1,
    pageSize: 10,
    total: 0,
  });

  // Èò≤ÊäñÊêúÁ¥¢
  const [searchDebounced, setSearchDebounced] = useState('');

  useEffect(() => {
    const timer = setTimeout(() => {
      setSearchDebounced(searchText);
    }, 500);

    return () => clearTimeout(timer);
  }, [searchText]);

  // Âà§Êñ≠ÊòØÂê¶ÂèØ‰ª•ÊéíÂ∫è
  const canSort = useMemo(() => {
    return sortBy === 'order' && !searchDebounced && !statusFilter && categoryFilter !== '';
  }, [sortBy, searchDebounced, statusFilter, categoryFilter]);

  // Ëé∑ÂèñÊñáÁ´†ÂàóË°®ÔºàÂ∏¶ÁºìÂ≠òÔºâ
  const fetchArticles = useCallback(async (params?: any) => {
    // Â¶ÇÊûúÊ≤°Êúâ‰º†ÂÖ•ÂèÇÊï∞ÔºåÊûÑÂª∫ÂΩìÂâçÂèÇÊï∞
    const requestParams = params || {
      page: pagination.current,
      limit: pagination.pageSize,
      sortBy: sortBy,
      ...(statusFilter && { status: statusFilter }),
      ...(categoryFilter && { categoryId: categoryFilter }),
      ...(searchDebounced && { search: searchDebounced }),
    };

    try {
      setLoading(true);

      // ÂÖàÂ∞ùËØï‰ªéÁºìÂ≠òËé∑Âèñ
      const cached = articleCache.get(requestParams);
      if (cached) {
        console.log('üíæ ‰ªéÁºìÂ≠òËé∑ÂèñÊï∞ÊçÆ:', {
          itemsCount: cached.items?.length || 0,
          pagination: cached.pagination,
          requestParams
        });
        setArticles(cached.items || []);
        setOriginalArticles(cached.items || []);
        setPagination(prev => ({
          ...prev,
          total: cached.pagination.total || 0,
        }));
        setLoading(false);
        return;
      }

      const response = await articlesService.getArticles(requestParams);
      // ÁºìÂ≠òÊï∞ÊçÆ
      articleCache.set(requestParams, response);

      setArticles(response.items || []);
      setOriginalArticles(response.items || []);
      setPagination(prev => ({
        ...prev,
        total: response.pagination.total || 0,
      }));
    } catch (error) {
      antMessage.error('Ëé∑ÂèñÊñáÁ´†ÂàóË°®Â§±Ë¥•');
      setArticles([]);
      setOriginalArticles([]);
      setPagination(prev => ({ ...prev, total: 0 }));
    } finally {
      setLoading(false);
    }
  }, [sortBy]);

  // Ëé∑ÂèñÂàÜÁ±ªÂàóË°®
  const fetchCategories = useCallback(async () => {
    try {
      const response = await articlesService.getArticleCountByCategory();
      setCategories(response || []);
    } catch (error) {
      antMessage.error('Ëé∑ÂèñÂàÜÁ±ªÂàóË°®Â§±Ë¥•');
    }
  }, []);

  // Âà†Èô§ÊñáÁ´†
  const handleDelete = useCallback(async (id: string) => {
    try {
      await articlesService.deleteArticle(id);
      antMessage.success('Âà†Èô§ÊàêÂäü');

      // Ê∏ÖÁêÜÁºìÂ≠ò
      articleCache.clear();

      // ÊûÑÂª∫ÂΩìÂâçÈ°µËØ∑Ê±ÇÂèÇÊï∞ÔºåÈáçÊñ∞Ëé∑ÂèñÂΩìÂâçÈ°µÊï∞ÊçÆ
      const refreshParams: any = {
        page: pagination.current,
        limit: pagination.pageSize,
        sortBy: sortBy
      };

      if (statusFilter) {
        refreshParams.status = statusFilter;
      }
      if (categoryFilter) {
        refreshParams.categoryId = categoryFilter;
      }
      if (searchDebounced) {
        refreshParams.search = searchDebounced;
      }

      fetchArticles(refreshParams);
    } catch (error) {
      antMessage.error('Âà†Èô§Â§±Ë¥•');
    }
  }, [fetchArticles, pagination.current, pagination.pageSize, statusFilter, categoryFilter, searchDebounced, sortBy]);

  // Â§ÑÁêÜÊãñÊãΩÊéíÂ∫è
  const moveRow = useCallback(
    (dragIndex: number, hoverIndex: number) => {
      if (!canSort) return;

      const draggedRow = articles[dragIndex];
      const newArticles = [...articles];
      newArticles.splice(dragIndex, 1);
      newArticles.splice(hoverIndex, 0, draggedRow);

      setArticles(newArticles);
    },
    [articles, canSort]
  );

  // ‰øùÂ≠òÊéíÂ∫è
  const saveOrder = useCallback(async () => {
    if (!canSort || JSON.stringify(articles) === JSON.stringify(originalArticles)) {
      return;
    }

    try {
      setLoading(true);

      // ÈáçÊñ∞ËÆ°ÁÆóorderÂÄº
      const updatedArticles = articles.map((article, index) => ({
        _id: article._id!,
        order: index + 1
      }));

      await articlesService.updateArticlesOrder(updatedArticles);
      antMessage.success('ÊéíÂ∫è‰øùÂ≠òÊàêÂäü');

      // Ê∏ÖÁêÜÁºìÂ≠òÂπ∂ÈáçÊñ∞Ëé∑ÂèñÊï∞ÊçÆ
      articleCache.clear();
      setOriginalArticles([...articles]);

      const refreshParams: any = {
        page: pagination.current,
        limit: pagination.pageSize,
        sortBy: sortBy,
        categoryId: categoryFilter
      };

      fetchArticles(refreshParams);
    } catch (error) {
      antMessage.error('ÊéíÂ∫è‰øùÂ≠òÂ§±Ë¥•');
      // ÊÅ¢Â§çÂéüÂßãÈ°∫Â∫è
      setArticles([...originalArticles]);
    } finally {
      setLoading(false);
    }
  }, [articles, originalArticles, canSort, pagination.current, pagination.pageSize, sortBy, categoryFilter, fetchArticles]);

  // ÈáçÁΩÆÊéíÂ∫è
  const resetOrder = useCallback(() => {
    setArticles([...originalArticles]);
  }, [originalArticles]);

  // Â§ÑÁêÜÂàÜÈ°µÂèòÂåñ
  const handleTableChange = useCallback((paginationConfig: { current: number; pageSize: number }) => {
    const { current: newCurrent, pageSize: newPageSize } = paginationConfig;

    // ÂÖàÊõ¥Êñ∞ÂàÜÈ°µÁä∂ÊÄÅ
    setPagination(prev => ({
      ...prev,
      current: newCurrent,
      pageSize: newPageSize,
    }));

    // Á´ãÂç≥ÊûÑÂª∫Êñ∞ÁöÑËØ∑Ê±ÇÂèÇÊï∞Âπ∂Ëé∑ÂèñÊï∞ÊçÆ
    const newParams: any = {
      page: newCurrent,
      limit: newPageSize,
      sortBy: sortBy
    };

    // Ê∑ªÂä†ÂΩìÂâçÁöÑÁ≠õÈÄâÊù°‰ª∂
    if (statusFilter) {
      newParams.status = statusFilter;
    }
    if (categoryFilter) {
      newParams.categoryId = categoryFilter;
    }
    if (searchDebounced) {
      newParams.search = searchDebounced;
    }

    fetchArticles(newParams);
  }, [statusFilter, categoryFilter, searchDebounced, fetchArticles, sortBy]);

  // Â§ÑÁêÜÁ≠õÈÄâÊù°‰ª∂ÂèòÂåñ
  useEffect(() => {
    // ÈáçÁΩÆÂà∞Á¨¨‰∏ÄÈ°µÂπ∂Á´ãÂç≥ËØ∑Ê±ÇÊï∞ÊçÆ
    const resetParams: any = {
      page: 1,
      limit: pagination.pageSize,
      sortBy: sortBy
    };

    if (statusFilter) {
      resetParams.status = statusFilter;
    }
    if (categoryFilter) {
      resetParams.categoryId = categoryFilter;
    }
    if (searchDebounced) {
      resetParams.search = searchDebounced;
    }

    setPagination(prev => ({ ...prev, current: 1 }));
    fetchArticles(resetParams);
  }, [statusFilter, categoryFilter, searchDebounced, fetchArticles, pagination.pageSize, sortBy]);

  // È¶ñÊ¨°Âä†ËΩΩÊï∞ÊçÆ
  useEffect(() => {
    fetchArticles();
  }, []);

  // ÂàùÂßãÂåñÂä†ËΩΩÂàÜÁ±ª
  useEffect(() => {
    fetchCategories();
  }, [fetchCategories]);

  // Ê£ÄÊü•ÊòØÂê¶ÊúâÊú™‰øùÂ≠òÁöÑÊéíÂ∫èÂèòÂåñ
  const hasOrderChanges = useMemo(() => {
    return JSON.stringify(articles) !== JSON.stringify(originalArticles);
  }, [articles, originalArticles]);

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="p-6">
        {/* Â§¥ÈÉ® */}
        <div className="mb-6 flex justify-between items-center">
          <h1 className="text-2xl font-bold text-gray-800">ÊäÄÊúØÊñáÊ°£ÁÆ°ÁêÜ</h1>
          <Space>
            <Button
              type="primary"
              icon={<ApartmentOutlined />}
              onClick={() => setShowCategoryModal(true)}
              style={{ background: '#22c55e' }}
            >
              ÁÆ°ÁêÜÂàÜÁ±ª
            </Button>
            <Link href="/admin/articles/new" passHref>
              <Button type="primary" icon={<PlusOutlined />} style={{ background: '#3b82f6' }}>
                Êñ∞Âª∫ÊñáÊ°£
              </Button>
            </Link>
          </Space>
        </div>

        {/* ÊêúÁ¥¢ÂíåÁ≠õÈÄâ */}
        <div className="mb-4 flex gap-4 flex-wrap items-center">
          <Search
            placeholder="ÊêúÁ¥¢ÊñáÁ´†Ê†áÈ¢ò"
            allowClear
            style={{ width: 300 }}
            value={searchText}
            onChange={e => setSearchText(e.target.value)}
          />
          <Select
            style={{ width: 200 }}
            value={categoryFilter}
            onChange={setCategoryFilter}
            placeholder="ÈÄâÊã©ÂàÜÁ±ª"
            allowClear
          >
            <Select.Option value="">ÂÖ®ÈÉ®ÂàÜÁ±ª</Select.Option>
            {categories?.map(category => (
              <Select.Option key={category.categoryId} value={category.categoryId}>
                {category.categoryName}
              </Select.Option>
            ))}
          </Select>
          <Select
            style={{ width: 200 }}
            value={statusFilter}
            onChange={value => setStatusFilter(value)}
            placeholder="ÈÄâÊã©Áä∂ÊÄÅ"
            allowClear
          >
            <Select.Option value="">ÂÖ®ÈÉ®Áä∂ÊÄÅ</Select.Option>
            <Select.Option value={ArticleStatus.PUBLISHED}>Â∑≤ÂèëÂ∏É</Select.Option>
            <Select.Option value={ArticleStatus.DRAFT}>ËçâÁ®ø</Select.Option>
          </Select>
          <Select
            style={{ width: 200 }}
            value={sortBy}
            onChange={value => setSortBy(value)}
            placeholder="ÊéíÂ∫èÊñπÂºè"
          >
            <Select.Option value="latest">ÊåâÊó∂Èó¥ÊéíÂ∫è</Select.Option>
            <Select.Option value="order">ÊåâËá™ÂÆö‰πâÊéíÂ∫è</Select.Option>
          </Select>
        </div>

        {/* ÊéíÂ∫èÊèêÁ§∫ÂíåÊìç‰Ωú */}
        {canSort && (
          <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
            <div className="flex justify-between items-center">
              <div className="text-blue-700">
                <HolderOutlined className="mr-2" />
                ÂΩìÂâçÂèØËøõË°åÊãñÊãΩÊéíÂ∫èÔºåÊãñÊãΩË°åÂèØË∞ÉÊï¥ÊñáÁ´†È°∫Â∫è
              </div>
              <Space>
                {hasOrderChanges && (
                  <>
                    <Button onClick={resetOrder} size="small">
                      ÈáçÁΩÆ
                    </Button>
                    <Button
                      type="primary"
                      onClick={saveOrder}
                      size="small"
                      loading={loading}
                    >
                      ‰øùÂ≠òÊéíÂ∫è
                    </Button>
                  </>
                )}
              </Space>
            </div>
          </div>
        )}

        {/* ÊñáÁ´†ÂàóË°® */}
        <Table
          columns={getColumns(categories, handleDelete, canSort)}
          dataSource={articles}
          rowKey="_id"
          loading={loading}
          pagination={{
            current: pagination.current,
            pageSize: pagination.pageSize,
            total: pagination.total,
            showTotal: (total, range) => {
              const currentPageCount = articles.length;
              return `Á¨¨ ${range[0]}-${range[1]} Êù°ÔºåÂÖ± ${total} Êù° (ÂΩìÂâçÈ°µ: ${currentPageCount} Êù°)`;
            },
            showSizeChanger: true,
            showQuickJumper: true,
            pageSizeOptions: ['10', '20', '50', '100'],
            onChange: (page, pageSize) => {
              handleTableChange({ current: page, pageSize });
            },
            onShowSizeChange: (current, size) => {
              handleTableChange({ current, pageSize: size });
            },
          }}
          components={canSort ? {
            body: {
              row: (props: any) => {
                const index = articles.findIndex(x => x._id === props['data-row-key']);
                return <DragableRow index={index} moveRow={moveRow} {...props} />;
              },
            },
          } : undefined}
        />

        {/* ÂàÜÁ±ªÁÆ°ÁêÜÊ®°ÊÄÅÊ°Ü */}
        {showCategoryModal && (
          <CategoryModal
            isOpen={showCategoryModal}
            onClose={() => setShowCategoryModal(false)}
            onCategoriesChange={fetchCategories}
          />
        )}
      </div>
    </DndProvider>
  );
};

export default ArticlesPage;